# 该目录为SugarCode的python编译与反编译代码

**注：SugarCode更准确来说是一种数据存储格式，这样的格式在写例如触发组、背包这样的功能时会更方便**

## SugarCode格式如下

* 用“@条件”表示一个新的触发器,且接下来的所有调用均为条件 

* 用“@效果”表示一个触发器条件的输入完毕，且接下来的所有调用均为效果

*  用“>”表示一个新调用的开始

*  用“|”表示调用的函数的参数的输入

*  用“,”来隔开参数

*  用“""”来表示一个文本类型，且允许换行

*  用“T与F”表示一个布尔类型

*  用“123这类普通数字”表示一个数字类型(支持小数)

*  用“[]”来表示一个数据组

*  用“#注释#”来表示一个注释

## SugarCode编译后是一个列表，列表中每一个都是一个字典，表示一个触发块
例：
```例子.sgc
@条件
    >proba | 25
    >needMode | "主动"
    >haveBuff | [0,"魔力天平",F]
@效果
    >changeBuffSelf | [1,1,10,0,-5,"附着度"]
    >changeBuffSelf | [0,1,50,0,1,"剩余回合"]
    >appendString | "<n>[我方]:恒魔勋章-发动!"

@条件
    >proba | 40
    >needMode | "主动"
    >haveBuff | [0,"魔力天平",T]
@效果
    >changeBuffSelf | [1,1,10,0,-5,"附着度"]
    >changeBuffSelf | [0,1,50,0,1,"剩余回合"]
    >appendString | "<n>[我方]:恒魔勋章-发动!"
```
该SugarCode格式数据编译为列表后为
```例子.json
[

{"条件":[
  {"调用":"proba","参数":25},
  {"调用":"needMode","参数":"主动"},
  {"调用":"haveBuff","参数":[0,"魔力天平",false]}
],"效果":[
  {"调用":"changeBuffSelf","参数":[1,1,10,0,-5,"附着度"]},
  {"调用":"changeBuffSelf","参数":[0,1,50,0,1,"剩余回合"]},
  {"调用":"appendString","参数":"<n>[我方]:恒魔勋章-发动!"
}]

},{"条件":[
  {"调用":"proba","参数":40},
  {"调用":"needMode","参数":"主动"},
  {"调用":"haveBuff","参数":[0,"魔力天平",true]}
],"效果":[
  {"调用":"changeBuffSelf","参数":[1,1,10,0,-5,"附着度"]},
  {"调用":"changeBuffSelf","参数":[0,1,50,0,1,"剩余回合"]},
  {"调用":"appendString","参数":"<n>[我方]:恒魔勋章-发动!"}
]}

]
```
## SugarCode目前只支持以下数据类型
* 字符型
* 整数型/浮点型
* 列表格式(可套娃)
* 布尔型
* **不支持字典型**

转化方式如下：
* True->T
* False->F
* 123->123
* 字符[hello world,hello "SugarCode"]->"hello world,hello \\\"SugarCode\\\""

## SugarCode的特殊性质
* 当参数只有一个时,允许不用[]将参数括起来
* 当参数不止一个时,**必须**用[]将参数括起来
* 字符类数据允许换行，类似python中的"""abc"""
* 注释也允许换行，以“#”开始，“#”结束（但目前不支持在注释中写“#”）
* 注释允许打在参数之间，例如
```
@条件
@效果
    >proAW | [
        0,#选择己方#
        1,#提升一倍#
        0,
        #最低为0#
        50
        #最高50#
    ]
```
* 在格式上无视空格与换行，例如以下数据与上面的数据编译出来内容是一样的
```
@条件@效果>proAW|[0,1,0,50]
```
(编译出来均为以下内容)
```json
[{"条件":[],"效果":[{"调用":"proAW","参数":[0,1,0,50]}]}]
```

## SugarCode使用例
比如我们想要编写一个激活码功能，但有时激活码里的内容就连类型都不一样

例如一个激活码里可能可以给予金币，同时也给予经验值等其他类型的物品

这时候我们就可以使用SugarCode来解决这个问题

首先我们分析这个问题中我们有哪些类型，很明显，有“金币”与“经验值”两种类型的物品

那么假如给予500金币与300经验值，我们可以编写以下内容
```实例.sgc
@条件@效果
    > coin | 500
    > exp  | 300
```
然后导入SugarCode库，调用“dumps”函数，将参数“noCondition”设为True（因为激活码系统不需要考虑条件）
```python
from . import SugarCode
exampleString = """
@条件@效果
    > coin | 500
    > exp  | 300
"""
exampleList = SugarCode.dumps(exampleString,noCondition=True)
```
此时exampleList的内容如下：
```json
[{"调用": "coin", "参数": 500}, {"调用": "exp", "参数": 300}]
```
然后我们遍历这一个列表
```python
from group in exampleList:
    Uname=k["调用"]
    Upmt=k["参数"]      
```
接下来只需要用if-elif来判断调用的内容即可完成激活码功能的编写啦！
```python
if Uname == "coin":
    ...
elif Uname == "exp":
    ...
```
